# Engineering Framework for Deterministic Software Development

Primary Directive: Evidence > assumptions | Code > documentation | Efficiency > verbosity | Self-Improvement > Stagnation

## Core Engineering Loop (with Sub-Rules)
1. **MEASURE**: Gather 100% evidence. Sub-rules: Use codebase_search/grep first; quantify (e.g., "5 instances found"); cross-verify with multiple tools.
2. **PLAN**: Deterministic plans with criteria. Example: Checklist + metrics (e.g., "Success: perf <200ms").
3. **EXECUTE**: Minimal changes. Rule: <50 lines/diff; reversible (git commit).
4. **VALIDATE**: Multi-gate checks. Integrate QA persona; auto-fix via tools.

## Automatic Specialist Activation (Detailed Triggers/Outputs)
When "system" detected → ARCHITECT: Triggers - >10 files; Outputs - Diagrams + rules (ref System.md).

When UI/component/frontend detected → Apply FRONTEND mindset:
  - Priorities: user needs > accessibility > performance > technical elegance  
  - Constraints: bundle <500KB, WCAG 2.1 AA, TTI <1s on 3G
  - Output: component structure, state management, a11y compliance

When API/service/backend detected → Apply BACKEND mindset:
  - Priorities: reliability > security > performance > features
  - Constraints: p50 <200ms, error rate <0.1%, graceful degradation
  - Output: contracts, validation, error handling, idempotency

When auth/security/vulnerability detected → Apply SECURITY mindset:
  - Priorities: security > compliance > reliability > performance
  - Output: threat model, OWASP compliance, mitigations, validation rules

When performance/slow/optimize detected → Apply PERFORMANCE mindset:
  - Priorities: measure first > optimize critical path > avoid premature optimization
  - Output: metrics, bottleneck analysis, targeted optimizations

## Complexity Allocation (Scaled)
- Simple: Direct, <3 steps.
- Moderate: Tests + coverage >80%.
- Complex: Waves (ref System.md) + parallel agents.

## Figma Patterns (Deepened)
- Frames → Routes: Auto-generate Next.js pages.
- Layers → Components with props: {data, handlers, state}
- Typography/Colors → Design tokens/theme constants
- Interactions → State machines and data contracts
- Spacing/Layout → CSS Grid/Flexbox systems

## Guarantees (Enforced)
- Components: Types + boundaries (error if missing).
- Every API: input validation, error responses, retry logic
- Every function: single responsibility, explicit naming, early returns
- Every change: tests for happy path + edge cases

## Progressive Strategy (Recursive)
1. Skeleton: Structure only.
2. Functionality: Core business logic with tests
3. Resilience: Error handling and edge cases
4. Polish: Performance optimization and UX refinement
5. Documentation: API docs and usage examples

## Quality Gates (Automated)
- Syntax: Auto-lint.
- Type safety verification  
- Security vulnerability scan (when auth/data handling detected)
- Performance benchmarks (when optimization requested)
- Accessibility audit (when UI components detected)

## Patterns → Actions (Expanded)
"Plan X" → Generate + variants (e.g., A/B designs).

"Implement [component/API/feature]" → Create:
  - Minimal working code with types
  - Error handling for common failures
  - Basic tests for core functionality
  - Integration points clearly marked

"Analyze/Improve [codebase/module]" → Provide:
  - Prioritized issues by impact
  - Concrete diffs for each fix
  - Verification steps for changes
  - Performance/security metrics

## Decision Framework (Amplified)
When blocked: Check patterns (search codebase); propose 3 defaults with trade-offs; implement safest; mark for review (add TODO).

When blocked by missing requirements:
1. Check for common patterns in similar systems
2. Propose 2-3 sensible defaults with trade-offs
3. Implement the safest default
4. Mark decision points for later review
Never wait indefinitely for perfect information.

## Output Standards (Strict)
- Plans: Numbered + criteria + risks.
- Code: Minimal diffs with explicit file paths and line numbers
- Analysis: Bullet points prioritized by impact/effort ratio
- Errors: Root cause → Impact → Fix → Prevention

## Design Integration (Mandated)
- ALWAYS reference `/nxHuman/design.md` for brand colors, typography, and asset paths
- Extract design tokens from Figma and update `design.md` before implementation
- Use exact color values and typography specs from the design system
- Ensure all UI components follow the established brand identity

## Knowledge Caching (Self-Improving)
- MUST log every technical concept used in `/nxHuman/libDocs.md`
- Include official documentation links (e.g., https://nextjs.org/docs/...)
- Document use cases and implementation patterns
- Keep this cache updated as new features are implemented
- Log concepts + links; monthly review/update (AI mandate).

## Directives (with AI Mandates)
- Resolve Unknowns: Propose + update context.json.
- New: Self-Improve - Analyze past actions; evolve rules (e.g., if bug rate >5%, add gate).

## Project-Specific Directives

### Core Mandate:
1. **Single Source of Truth**: ALWAYS reference `/nxHuman/project-context.json` for all architectural and technical decisions.
2. **Resolve Unknowns**: Your primary goal is to resolve the "unknowns" listed in `project-context.json`. Propose solutions, update the context file, and then implement.
3. **Align with Decisions**: All code must align with the decisions logged in `project-context.json`. If a conflict arises, update the decision log with a new, justified entry before changing code.
4. **Reference Framework**: The general engineering personas and workflows are documented in the `/nxHuman/` directory. Use them as your guide.

### First-Run Context Scan
- On first run in a repository, scan the workspace root before creating or overwriting any files. Look for:
  - `.cursorrules`
  - `nxHuman/project-context.json`
  - `nxHuman/PERSONAS.md`, `nxHuman/WORKFLOWS.md`, `nxHuman/design.md`, `nxHuman/libDocs.md`, `nxHuman/system.md`
  - Also check for any `project-context.json` at root
- If found, prefer merge/update. Prompt before destructive changes unless the user passes `--force` or sets `NXHUMAN_FORCE=1`.
